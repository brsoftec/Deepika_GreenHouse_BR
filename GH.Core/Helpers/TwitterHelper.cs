using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Security.Cryptography;
using System.Text;
using System.Web;

namespace GH.Core.Helpers
{

    public enum TwitterApiHttpMethod
    {
        GET,
        POST
    }

    public class TwitterHeaders
    {
        /// <summary>
        /// The oauth_signature_method used by Twitter is HMAC-SHA1. This value should be used for any authorized request sent to Twitter’s API.
        /// </summary>
        public string OAuthSignatureMethod { get { return "HMAC-SHA1"; } }
        /// <summary>
        /// The oauth_version parameter should always be 1.0 for any request sent to the Twitter API.
        /// </summary>
        public string OAuthVersion { get { return "1.0"; } }
        /// <summary>
        /// The oauth_nonce parameter is a unique token your application should generate for each unique request. Twitter will use this value to determine whether a request has been submitted multiple times. The value for this request was generated by base64 encoding 32 bytes of random data, and stripping out all non-word characters, but any approach which produces a relatively random alphanumeric string should be OK here.
        /// </summary>
        public string OAuthNonce { get; set; }
        /// <summary>
        /// The oauth_timestamp parameter indicates when the request was created. This value should be the number of seconds since the Unix epoch at the point the request is generated, and should be easily generated in most programming languages. Twitter will reject requests which were created too far in the past, so it is important to keep the clock of the computer generating requests in sync with NTP.
        /// </summary>
        public string OAuthTimeStamp { get; set; }
        /// <summary>
        /// The oauth_signature parameter contains a value which is generated by running all of the other request parameters and two secret values through a signing algorithm. The purpose of the signature is so that Twitter can verify that the request has not been modified in transit, verify the application sending the request, and verify that the application has authorization to interact with the user’s account. Processes: https://dev.twitter.com/oauth/overview/creating-signatures
        /// </summary>
        public string Signature { get; set; }

        public string ConsumerKey { get; set; }
        public string ConsumerSecret { get; set; }
        public string OAuthToken { get; set; }
        public string OAuthTokenSecret { get; set; }
        public string HttpMethod { get; set; }

        public override string ToString()
        {
            StringBuilder authorizationHeaderParams = new StringBuilder();
            authorizationHeaderParams.Append("OAuth ");
            authorizationHeaderParams.Append("oauth_consumer_key=" + "\"" + Uri.EscapeDataString(this.ConsumerKey) + "\",");
            authorizationHeaderParams.Append("oauth_nonce=" + "\"" + Uri.EscapeDataString(this.OAuthNonce) + "\",");
            authorizationHeaderParams.Append("oauth_signature=" + "\"" + Uri.EscapeDataString(this.Signature) + "\",");
            authorizationHeaderParams.Append("oauth_signature_method=" + "\"" + Uri.EscapeDataString(this.OAuthSignatureMethod) + "\",");
            authorizationHeaderParams.Append("oauth_timestamp=" + "\"" + Uri.EscapeDataString(this.OAuthTimeStamp) + "\",");
            if (!string.IsNullOrEmpty(this.OAuthToken))
                authorizationHeaderParams.Append("oauth_token=" + "\"" + Uri.EscapeDataString(this.OAuthToken) + "\",");
            authorizationHeaderParams.Append("oauth_version=" + "\"" + Uri.EscapeDataString(this.OAuthVersion) + "\"");
            return authorizationHeaderParams.ToString();
        }
    }

    public class TwitterHelper
    {
        public const string TWITTER_API_BASE_URL = "https://api.twitter.com/1.1";
        public const string ACCOUNT_VERIFY_CREDENTIALS = "/account/verify_credentials.json";
        public const string STATUS_HOME_TIMELINE = "/statuses/home_timeline.json";
        public const string STATUS_UPDATE = "/statuses/update.json";
        public const string FAVORITE_CREATE = "/favorites/create.json";
        public const string FAVORITE_DESTROY = "/favorites/destroy.json";
        public const string STATUS_RETWEET = "/statuses/retweet/{0}.json"; //{0} : id
        public const string STATUS_UNRETWEET = "/statuses/unretweet/{0}.json"; //{0} : id

        public static TwitterHeaders GenerateHeaders(string consumerKey, string consumerSecret, string oauthToken, string oauthTokenSecret, string api, IDictionary<string, string> parameters, TwitterApiHttpMethod method)
        {
            TwitterHeaders headers = new TwitterHeaders();

            headers.ConsumerKey = consumerKey;
            headers.ConsumerSecret = consumerSecret;
            headers.OAuthToken = oauthToken;
            headers.OAuthTokenSecret = oauthTokenSecret;
            headers.HttpMethod = method.ToString();

            headers.OAuthNonce = Convert.ToBase64String(new ASCIIEncoding().GetBytes(DateTime.Now.Ticks.ToString()));


            TimeSpan ts = DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);
            headers.OAuthTimeStamp = Convert.ToInt64(ts.TotalSeconds).ToString();
            //Build the signature string
            SortedDictionary<string, string> basestringParameters = new SortedDictionary<string, string>();
            basestringParameters.Add("oauth_version", headers.OAuthVersion);
            basestringParameters.Add("oauth_consumer_key", headers.ConsumerKey);
            basestringParameters.Add("oauth_nonce", headers.OAuthNonce);
            basestringParameters.Add("oauth_signature_method", headers.OAuthSignatureMethod);
            basestringParameters.Add("oauth_timestamp", headers.OAuthTimeStamp);
            basestringParameters.Add("oauth_token", headers.OAuthToken);
            foreach (var item in parameters)
            {
                basestringParameters.Add(item.Key, Uri.EscapeDataString(item.Value));
            }

            StringBuilder baseString = new StringBuilder();
            baseString.Append(headers.HttpMethod + "&");
            baseString.Append(EncodeCharacters(Uri.EscapeDataString(api) + "&"));
            baseString.Append(EncodeCharacters(Uri.EscapeDataString(string.Join("&", basestringParameters.Select(entry => entry.Key + "=" + entry.Value)))));
            string finalBaseString = baseString.ToString();

            //Build the signing key
            string signingKey = EncodeCharacters(Uri.EscapeDataString(headers.ConsumerSecret)) + "&" + EncodeCharacters(Uri.EscapeDataString(headers.OAuthTokenSecret));

            //Sign the request
            HMACSHA1 hasher = new HMACSHA1(new ASCIIEncoding().GetBytes(signingKey));
            headers.Signature = Convert.ToBase64String(hasher.ComputeHash(new ASCIIEncoding().GetBytes(finalBaseString)));

            return headers;
        }

        #region helpers

        /// <summary>
        /// https://dev.twitter.com/oauth/overview/percent-encoding-parameters
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        public static string EncodeCharacters(string data)
        {
            //as per OAuth Core 1.0 Characters in the unreserved character set MUST NOT be encoded
            //unreserved = ALPHA, DIGIT, '-', '.', '_', '~'
            if (data.Contains("!"))
                data = data.Replace("!", "%21");
            if (data.Contains("'"))
                data = data.Replace("'", "%27");
            if (data.Contains("("))
                data = data.Replace("(", "%28");
            if (data.Contains(")"))
                data = data.Replace(")", "%29");
            if (data.Contains("*"))
                data = data.Replace("*", "%2A");
            if (data.Contains(","))
                data = data.Replace(",", "%2C");

            return data;
        }
        #endregion
    }
}